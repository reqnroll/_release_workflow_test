name: CI

on:
  push:
    branches: 
      - 'main'
    paths-ignore:
      - 'docs/**'
      - README.md
      - CHANGELOG.md
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      configuration:
        description: 'Build Configuration'
        required: true
        default: 'Debug'
        type: choice
        options:
        - Debug
        - Release
      production_release:
        description: 'If the build produces a production package'
        type: boolean
        default: false
        required: true
      version_suffix:
        description: 'Suffix for the NuGet packages (without leading -). Build ID will be appended. Use "-" to force empty.'
        required: false

permissions:
  checks: write


jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      product_version_prefix: ${{ steps.versions.outputs.product_version_prefix }}
      product_version_suffix: ${{ steps.versions.outputs.product_version_suffix }}
      product_main_version: ${{ steps.versions.outputs.product_main_version }}
      product_patch_version: ${{ steps.versions.outputs.product_patch_version }}
      product_full_version: ${{ steps.versions.outputs.product_full_version }}
      product_configuration: ${{ steps.versions.outputs.product_configuration }}
      production_release: ${{ steps.versions.outputs.production_release }}

    steps:
    - uses: actions/checkout@v4
    - id: versions
      name: Calculate versions
      shell: pwsh
      run: |
        $productionReleaseSetting = "${{ inputs.production_release }}"
        $productionRelease = $false
        if ($productionReleaseSetting -eq 'true') {
            $productionRelease = $true
        }
        $productionReleaseValue = $productionRelease.ToString().ToLowerInvariant()
        Write-Output "production_release=$productionReleaseValue" >> $env:GITHUB_OUTPUT        
        Write-Output "Production release: $productionRelease ($productionReleaseValue)"

        $versionSuffix = "${{ inputs.version_suffix }}"
        if ($versionSuffix -eq "") {
            $date = [datetime]::Today
            $dateString = $date.ToString('yyyyMMdd')
            $versionSuffix = "ci$dateString-${env:GITHUB_RUN_NUMBER}"
        }
        elseif ($versionSuffix -eq "-") {
            $versionSuffix = ""
        }
        else {
            $versionSuffix = "$versionSuffix-${env:GITHUB_RUN_NUMBER}"
        }
        Write-Output "product_version_suffix=$versionSuffix" >> $env:GITHUB_OUTPUT
        Write-Output "Product Version Suffix: $versionSuffix"
        
        $productConfig = "${{ inputs.configuration }}"
        if ($productConfig -eq "") {
            $productConfig = "Debug"
        }
        Write-Output "product_configuration=$productConfig" >> $env:GITHUB_OUTPUT
        Write-Output "Product Configuration: $productConfig"

        $buildPropsXml = [xml](Get-Content Directory.Build.props)
        $versionPrefix = $($buildPropsXml.Project.PropertyGroup.VersionPrefix)[1].Trim()
        Write-Output "product_version_prefix=$versionPrefix" >> $env:GITHUB_OUTPUT
        Write-Output "Product Version Prefix: $versionPrefix"

        $mainVersion = &{$versionPrefix -match '^\d+\.\d+' > $null; $matches[0]}
        Write-Output "product_main_version=$mainVersion" >> $env:GITHUB_OUTPUT
        Write-Output "Product Main Version: $mainVersion"

        $patchVersion = &{$versionPrefix -match '\d+$' > $null; $matches[0]}
        Write-Output "product_patch_version=$patchVersion" >> $env:GITHUB_OUTPUT
        Write-Output "Product Patch Version: $patchVersion"

        $fullVersion = $versionPrefix
        if ($versionSuffix -ne "") {
            $fullVersion = "$fullVersion-$versionSuffix"
        }
        Write-Output "product_full_version=$fullVersion" >> $env:GITHUB_OUTPUT
        Write-Output "Product Full Version: $fullVersion"

    - name: Simulate Build
      shell: pwsh
      run: |
        Write-Output "hello ${{ steps.versions.outputs.product_full_version }} (${{ steps.versions.outputs.product_main_version }})" > package.${{ steps.versions.outputs.product_version_prefix }}.txt
    - name: Upload packages
      uses: actions/upload-artifact@v4
      with:
        name: packages-v${{ steps.versions.outputs.product_full_version }}
        if-no-files-found: error
        path: "*.txt"

  # test-job-1:
  #   runs-on: ubuntu-latest
  #   needs: build

  #   steps:
  #   - uses: actions/checkout@v4
  #   - name: Simulate Test
  #     shell: pwsh
  #     run: |
  #       Write-Output "Testing ${{ needs.build.outputs.product_full_version }} (${{ needs.build.outputs.product_main_version }})"

  release-job:
    runs-on: ubuntu-latest
    # needs: [build, test-job-1]
    needs: [build]
    environment: production_environment
    if: github.ref == 'refs/heads/main' && needs.build.outputs.production_release == 'true'
    permissions:
      # Give the default GITHUB_TOKEN write permission to commit and push the
      # added or changed files to the repository.
      contents: write

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0 # avoid shallow clone so nbgv can do its work.
        ref: ${{ github.head_ref }}
        ssh-key: ${{secrets.RELEASE_GIT_SSH_KEY}}
    - uses: actions/download-artifact@v4
      with:
        name: packages-v${{ needs.build.outputs.product_full_version }}
        path: release_packages
    - name: Display structure of downloaded files
      run: ls -R
    - name: Simulate Deployment
      env:
        ENV_SECRET1: ${{ secrets.ENV_SECRET1 }}      
      shell: pwsh
      run: |
        Write-Output "Deploying (prod: ${{ needs.build.outputs.production_release }}) ${{ needs.build.outputs.product_full_version }} (${{ needs.build.outputs.product_main_version }}) / key: $env:ENV_SECRET1"

    - name: Calculate Next Version
      id: next_version
      shell: pwsh
      run: |
        $patchVersion = "${{ needs.build.outputs.product_patch_version }}"
        $newPatch = [int]$patchVersion + 1
        $nextVersion = "${{ needs.build.outputs.product_main_version }}.$nextPatch"
        Write-Output "product_next_version=$nextVersion" >> $env:GITHUB_OUTPUT
        Write-Output "Product Next Version: $nextVersion"

    - name: Simulate Bump Version
      shell: pwsh
      run: |
        Write-Output "${{ steps.next_version.outputs.product_next_version }}" >> versions.txt
        git status

    - name: Update Changelog
      shell: pwsh
      run: |
        $newHeading = "# [vNext]$([Environment]::NewLine)$([Environment]::NewLine)## Improvements:$([Environment]::NewLine)$([Environment]::NewLine)## Bug fixes:$([Environment]::NewLine)$([Environment]::NewLine)*Contributors of this release (in alphabetical order):* $([Environment]::NewLine)$([Environment]::NewLine)"
        $releaseDate = [System.DateTime]::Today.ToString("yyyy-MM-dd")
        $newHeading = $newHeading + "# ${{ needs.build.outputs.product_full_version }} - $releaseDate"
        $content = [System.IO.File]::ReadAllText("CHANGELOG.md").Replace("# [vNext]",$newHeading)
        [System.IO.File]::WriteAllText("CHANGELOG.md", $content)

    - name: Update changes in GitHub repository
      run: |
        git config --global user.name 'Reqnroll CI' 
        git config --global user.email 'ci@reqnroll.net'
        git tag v${{ needs.build.outputs.product_full_version }}
        git push origin tag v${{ needs.build.outputs.product_full_version }}
        git add -u
        git commit -m '[automated commit] bump version after release of ${{ needs.build.outputs.product_full_version }}'
        git push